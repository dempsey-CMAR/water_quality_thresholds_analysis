---
title: "Sensor Depth: Rolling Standard Deviation Thresholds Comparison"
format: 
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi = 600, fig.width = 8)

library(data.table)
library(DT)
library(dplyr)
library(ggplot2)
library(gtools)
library(here)
library(knitr)
library(lubridate)
library(plotly)
library(qaqcmar)
library(readr)
library(strings)
library(sensorstrings)
library(summaryplots)
library(tidyr)
library(viridis)

source(here("functions/subchunkify.R"))

theme_set(theme_light())

dt_options <- list(
  dom = 'ft',
  paging = FALSE,
  searching = TRUE,
  scrollY = "500px",
  columnDefs = list(list(className = 'dt-center', targets = "_all"))
)

# data - preliminary QC (only Olding Island Removed)
dat_roll <- readRDS(here("data/depth_rolling_sd_reprocessed.rds")) %>% 
  select(
    -c(sensor_type, int_sample, n_sample, 
       rolling_sd_flag_sensor_depth_measured_m)) %>% 
  na.omit() %>% 
  ss_pivot_longer() %>%
  mutate(
    depth = factor(depth_log),
    year = year(timestamp_utc),
    year = factor(year),
    month = month(timestamp_utc)
  ) %>% 
  separate(deployment_range, into = c("depl_start", NA), sep = " to ")

# calculate thresholds
thresholds <- readRDS(here("data/depth_rolling_sd_reprocessed.rds")) %>%
  select(-c(sensor_type, int_sample, n_sample, rolling_sd_flag_sensor_depth_measured_m)) %>%
  rename(sensor_depth_at_low_tide_m = depth_log) %>%
  ss_pivot_longer() %>%
  filter(
    !(station == "Olding Island" &
        deployment_range == "2022-Jun-03 to 2022-Sep-30" &
        sensor_depth_at_low_tide_m  == 3),
    # freshwater stations
    !(station %in% c("Piper Lake", "Hourglass Lake", "0193", "Sissiboo")),
    # suspect range
    !(station == "Long Beach" &
        deployment_range == "2020-Jul-16 to 2020-Nov-29" &
        sensor_depth_at_low_tide_m == 5),
    !(station == "Sandy Cove" &
        deployment_range == "2020-Jul-16 to 2020-Nov-30" &
        sensor_depth_at_low_tide_m  == 5),
    !(station == "Tickle Island 1" &
        deployment_range == "2020-Oct-21 to 2021-Aug-25" &
        sensor_depth_at_low_tide_m  == 5)
  ) %>%
  group_by(county, variable) %>%
  summarise(
    mean = mean(sd_roll, na.rm = TRUE),
    sd_var = sd(sd_roll, na.rm = TRUE),
    mean_2sd = mean + 2 * sd_var,
    mean_3sd = mean + 3 * sd_var,
    q_90 = quantile(sd_roll, probs = 0.90, na.rm = TRUE),
    q_95 = quantile(sd_roll, probs = 0.95, na.rm = TRUE),
    q_997 = quantile(sd_roll, probs = 0.997, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(across(where(is.numeric), round, digits = 2)) %>% 
  select(variable, county, contains("mean"), contains("q_"))

dat_summary <- dat_roll %>%
  left_join(thresholds, by = c("variable", "county")) %>% 
  mutate(
    thresh_2sd =  case_when(
      sd_roll > mean_2sd ~ 3,
      sd_roll <= mean_2sd ~ 1,
      is.na(sd_roll) ~ 2),
    thresh_3sd =  case_when(
      sd_roll > mean_3sd ~ 3,
      sd_roll <= mean_3sd ~ 1,
      is.na(sd_roll) ~ 2),
    thresh_q90 = case_when(
      sd_roll > q_90 ~ 3,
      sd_roll <= q_90 ~ 1,
      is.na(sd_roll) ~ 2),
    thresh_q95 = case_when(
      sd_roll > q_95 ~ 3,
      sd_roll <= q_95 ~ 1,
      is.na(sd_roll) ~ 2),
    thresh_q997 = case_when(
      sd_roll > q_997 ~ 3,
      sd_roll <= q_997 ~ 1,
      is.na(sd_roll) ~ 2)
  ) %>%
  mutate(across(where(is.numeric), round, digits = 2)) %>% 
  pivot_longer(
    cols = contains("thresh"),
    names_to = "threshold",
    values_to = "threshold_value", names_prefix = "thresh_"
  ) 

county_pal <- get_county_colour_palette(length(unique(dat_roll$county)))
flag_colours <- c("chartreuse4", "#E6E1BC", "#EDA247", "#DB4325", "grey24")

theme_facet_plotly <- theme(
  panel.spacing.y = unit(20, "lines"),
  panel.spacing.x = unit(15, "lines")
)
```

September 18, 2023

- Thresholds are based on filtered data
  - Freshwater stations not expected to have distinct tidal signal
    - Hourglass Lake, Piper Lake
  - Measured outside gross range
    - Olding Island, 2022-06-03, 3 m
  - Suspect range compared to other deployments in the area; likely the strings were pushed over by the tide and / or weighed down by biofouling.
    - Long Beach 2020-07-16, 5 m
    - Sandy Cove 2020-07-16, 5 m
    - Tickle Island 1 2020-10-21, 5 m 

- These thresholds are applied to the full data to assess which threshold will be the most useful for automated QC.
  - No preliminary QC was applied to the data.
  - It is expected that most observations (besides those mentioned above) will be considered "good".
  
- Potential thresholds:
```{r}
thresholds %>% 
  select(-variable) %>%
  datatable(options = dt_options, rownames = FALSE)
```


## Pooled

The percent of all observations flagged with each potential threshold.

::: panel-tabset

### Figure 1
```{r}
summary_all <- dat_summary %>%
  group_by(threshold) %>%
  summarise(n_obs = n(), n_suspect = sum(threshold_value == 3)) %>%
  mutate(percent_suspect = round((100 * n_suspect / n_obs), digits = 3)) %>%
  ungroup()

p <- ggplot(summary_all, aes(percent_suspect, threshold)) +
  geom_col(
    col = 1, fill = "#AE1759FF",
    position = position_dodge2(preserve = "single", padding = 0)
  ) +
  geom_vline(xintercept = 0) +
  scale_x_continuous(
    "Percent of Observations", expand = expansion(mult = c(0, 0.1))
  ) +
  scale_y_discrete(name = "Threshold", limits = rev)

ggplotly(p)
```

### Table 1
```{r}
datatable(
  summary_all,
  options = list(
    dom = 'ft',
    paging = FALSE,
    searching = FALSE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))), rownames = FALSE)
```
:::

## By County

The percent of observations within each county flagged with each potential threshold.

::: panel-tabset

### Figure 2
```{r}
#| fig-height: 8
#| message: false

summary_county <- dat_summary %>%
  group_by(county, threshold) %>%
  summarise(n_obs = n(), n_suspect = sum(threshold_value == 3)) %>%
  mutate(percent_suspect = round((100 * n_suspect / n_obs), digits = 3)) %>%
  ungroup()

p <- ggplot(summary_county, aes(percent_suspect, threshold)) +
  geom_col(
    col = 1, fill = "#AE1759FF",
    position = position_dodge2(preserve = "single", padding = 0)
  ) +
  geom_vline(xintercept = 0) +
  scale_x_continuous(
    "Percent of Observations", expand = expansion(mult = c(0, 0.1))
  ) +
  scale_y_discrete(name = "Threshold", limits = rev) +
  facet_wrap(~county, ncol = 3) +
  theme_facet_plotly

ggplotly(p)
```

### Table 2
```{r}
summary_county %>%
  select(-c(n_obs, n_suspect)) %>%
  pivot_wider(names_from = "threshold", values_from = "percent_suspect") %>%
  datatable(options = dt_options, rownames = FALSE)
```

:::

## By Deployment

The percent of observations within each deployment flagged with each potential threshold.

The `diff` column shows difference between the percent of observations flagged with the q_90 threshold and the q_997 (~ same as mean + 3 sd) threshold.

### Table 3
```{r}
#| message: false

summary_depl <- dat_summary %>%
  group_by(county, station, depl_start, threshold) %>%
  summarise(n_obs = n(), n_suspect = sum(threshold_value == 3)) %>%
  mutate(percent_suspect = round((100 * n_suspect / n_obs), digits = 3)) %>%
  ungroup() %>% 
  select(-c(n_obs, n_suspect)) %>% 
  pivot_wider(names_from = "threshold", values_from = "percent_suspect") %>%
  mutate(
    diff = q90 - q997,
    across(where(is.numeric), .fn = round, digits = 2)
  )

summary_depl %>% 
  datatable(options = dt_options, rownames = FALSE)
```

</br>

## Deployments with Largest `diff`

These figures show the flagged observations for each threshold for the deployments with the largest difference between thresholds.

::: panel-tabset

```{r}
#| results: "asis"

depl <- summary_depl %>% 
  arrange(desc(diff)) %>% 
  filter(diff >= 25)

thresh_plot <- unique(dat_summary$threshold)

for(i in 1:nrow(depl)){
 
  depl_i <- depl[i, 1:3]
  
  cat('\n###', paste(depl_i$station, depl_i$depl_start), '\n')
  
  for(j in seq_along(thresh_plot)) {
    
    cat('\n####', thresh_plot[j], '\n')
    
    dat_j <-  dat_summary %>% 
      filter(
        station == depl_i$station, 
        depl_start == depl_i$depl_start, 
        threshold == thresh_plot[j]
        )  %>%
      mutate(
        depth = paste0(depth_log, " m", " (", sensor_serial_number,")"),
        depth = ordered(depth, levels = gtools::mixedsort(unique(depth)))
      ) %>% 
      rename(sd_rolling_flag_value = threshold_value) %>% 
      qc_assign_flag_labels() 
    
    # height of figure j
    n_sensor <- length(unique(dat_j$sensor_serial_number))
    
    if(n_sensor == 1) h = 2.75
    if(n_sensor > 1) h = 2.75 * n_sensor
    
    p <- ggplot(
      dat_j, 
      aes(timestamp_utc, value, 
          colour = sd_rolling_flag_value )
      ) +
      geom_point()+
      scale_y_continuous("Measured Sensor Depth (m)") +
      scale_x_datetime("Date") +
      scale_colour_manual("Flag Value", values = flag_colours, drop = FALSE) +
      facet_wrap(~depth, ncol = 1) +
      theme_light() +
      theme(
        legend.position = "none",
        strip.text = element_text(colour = "black", size = 10),
        strip.background = element_rect(fill = "white", colour = "darkgrey")
      ) #+
      #guides(color = guide_legend(override.aes = list(size = 4)))
    
    subchunkify(p, fig_height = h, fig_width = 8.5)
    
  }
}
```
:::

## Deployments of Interest

These figures show the flagged observations for each threshold for several deployments with notable sensor depth signals.

::: panel-tabset

```{r}
#| results: "asis"

depl <- data.frame(
  station = c("Long Beach", "Sandy Cove",
              "The Bull", "Tickle Island 1",
              "Olding Island", "Shut-In Island"),
  depl_date = c("2020-Jul-16", "2020-Jul-16",
                "2020-Feb-25", "2020-Oct-21",
                "2022-Jun-03", "2020-Nov-08")
  )


for(i in 1:nrow(depl)){
  depl_i <- depl[i, ]

  cat('\n###', paste(depl_i$station, depl_i$depl_date), '\n')

  for(j in seq_along(thresh_plot)) {

    cat('\n####', thresh_plot[j], '\n')

    dat_j <-  dat_summary %>%
      filter(
        station == depl_i$station,
        depl_start == depl_i$depl_date,
        threshold == thresh_plot[j])  %>%
      mutate(
        depth = paste0(
          depth_log, " m",
          " (", sensor_serial_number, ")"),
        depth = ordered(depth, levels = gtools::mixedsort(unique(depth)))
      ) %>%
      rename(sd_rolling_flag_value = threshold_value) %>%
      qc_assign_flag_labels() %>% 
      ss_pivot_wider()

    if(nrow(dat_j) > 0) {

      # height of figure j
      n_sensor <- length(unique(dat_j$sensor_serial_number))

      if(n_sensor == 1) h = 2.75
      if(n_sensor > 1) h = 2.75 * n_sensor

      p <- ggplot(
        dat_j,
        aes(timestamp_utc, sensor_depth_measured_m,
            colour = sd_rolling_flag_value )
      ) +
        geom_point()+
        scale_y_continuous("Measured Depth (m)") +
        scale_x_datetime("Date") +
        scale_colour_manual("Flag Value", values = flag_colours, drop = FALSE) +
        facet_wrap(~depth, ncol = 1) +
        theme_light() +
        theme(
          legend.position = "none",
          strip.text = element_text(colour = "black", size = 10),
          strip.background = element_rect(fill = "white", colour = "darkgrey")
        )

       subchunkify(p, fig_height = h, fig_width = 8.5)
    }
  }
}
```
:::

## Conclusions

- Use mean + 3 sd
  - Most distributions are normally distributed
  - This threshold flags data with suspect range (as identified from 0.1_depth_additional_qc.html and 1.1_explore_depth_html), with few false positives.
    - See the "Deployments of Interest"


